# -*- coding: utf-8 -*-
"""NBA_Prospect_Schedule.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1720p_3d-J0zrYje1J53BWjFd3P5dle0l
"""

# prompt: loop through the next 7 days and combine all data frames and include the respective dates in a new column. There are two columns with team names. One does not have a header name. The first one is currently called "MATCHUP" and should be renamed "HOME", the column next to it should be titled ""AWAY" and all of the rest of the columns names should move 1 to the right.

from bs4 import BeautifulSoup as bs
import requests
from bs4 import BeautifulSoup
import pandas as pd
from datetime import date, timedelta

# pip install selenium beautifulsoup4 pandas is already in the provided code

all_dfs = []

today = date.today()

for i in range(7):
    current_date = today + timedelta(days=i)
    date_str = current_date.strftime("%Y%m%d")
    url = f"https://www.espn.com/mens-college-basketball/schedule/_/date/{date_str}"
    headers = {
        "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36"
    }
    response = requests.get(url, headers=headers)
    soup = BeautifulSoup(response.content, "html.parser")

    tables = soup.find_all("table")
    if tables: #check if table exists for that day
      target_table = tables[0]
      rows = target_table.find_all("tr")
      data = []
      for row in rows:
          cols = row.find_all(["th", "td"])
          cols = [col.text.strip() for col in cols]
          if cols:
              data.append(cols)

      df = pd.DataFrame(data)
      if not df.empty: #check if dataframe is empty
        df.columns = df.iloc[0]
        df = df.drop(0).reset_index(drop=True)



        df["Date"] = current_date
        all_dfs.append(df)

combined_df = pd.concat(all_dfs, ignore_index=True)
combined_df

# prompt: Rename columns to "HOME", "AWAY", "TIME", "TV", "TICKETS", "LOCATION", "ODDS", "DATE"

# Rename columns
combined_df = combined_df.rename(columns={
    combined_df.columns[0]: "HOME",
    combined_df.columns[1]: "AWAY",
    combined_df.columns[2]: "TIME",
    combined_df.columns[3]: "TV",
    combined_df.columns[4]: "TICKETS",
    combined_df.columns[5]: "LOCATION",
    combined_df.columns[6]: "ODDS",
    "Date": "DATE"
})

# Print the DataFrame with renamed columns
combined_df

# prompt: Add additional columns for the home and away but without any numbers or @ symbol and trimmed


# Add new columns and clean up existing columns
combined_df['HomeTeam'] = combined_df['HOME'].str.replace(r'[@0-9]', '', regex=True).str.strip()
combined_df['AwayTeam'] = combined_df['AWAY'].str.replace(r'[@0-9]', '', regex=True).str.strip()

#Optional: Drop original columns if needed
#combined_df = combined_df.drop(columns=['HOME', 'AWAY'])

combined_df

# prompt: scrape table from https://www.nbadraft.net/nba-mock-drafts/?year-mock=2025
# <table id="nba_mock_consensus_table" class="nba_mock_consensus_table mock-draft-table sof-tablepress sticky-enabled dataTable no-footer" role="grid" aria-describedby="nba_mock_consensus_table_info"><thead><tr role="row"><th class="rank sorting_asc" tabindex="0" aria-controls="nba_mock_consensus_table" rowspan="1" colspan="1" aria-sort="ascending" aria-label="#: activate to sort column descending" style="width: 11px;">#</th><th class="team sorting" tabindex="0" aria-controls="nba_mock_consensus_table" rowspan="1" colspan="1" aria-label="Team: activate to sort column ascending" style="width: 109px;">Team</th><th class="player sorting" tabindex="0" aria-controls="nba_mock_consensus_table" rowspan="1" colspan="1" aria-label="Player: activate to sort column ascending" style="width: 90px;">Player</th><th class="height sorting" tabindex="0" aria-controls="nba_mock_consensus_table" rowspan="1" colspan="1" aria-label="H: activate to sort column ascending" style="width: 29px;">H</th><th class="weight sorting" tabindex="0" aria-controls="nba_mock_consensus_table" rowspan="1" colspan="1" aria-label="W: activate to sort column ascending" style="width: 29px;">W</th><th class="teamposition sorting" tabindex="0" aria-controls="nba_mock_consensus_table" rowspan="1" colspan="1" aria-label="P: activate to sort column ascending" style="width: 45px;">P</th><th class="school sorting" tabindex="0" aria-controls="nba_mock_consensus_table" rowspan="1" colspan="1" aria-label="School: activate to sort column ascending" style="width: 70px;">School</th><th class="class sorting" tabindex="0" aria-controls="nba_mock_consensus_table" rowspan="1" colspan="1" aria-label="C: activate to sort column ascending" style="width: 18px;">C</th></tr></thead><tbody><tr class="row-index-0 odd" role="row"><td class="rank cell-1 sorting_1">1</td><td class="team cell-<img-src=&quot;https://nbadraft.net/wp-content/uploads/2013/05/pelicans.j

import requests
from bs4 import BeautifulSoup
import pandas as pd

def scrape_nba_mock_draft(url):
    response = requests.get(url)
    response.raise_for_status()  # Raise an exception for bad status codes

    soup = BeautifulSoup(response.content, "html.parser")
    table = soup.find("table", {"id": "nba_mock_consensus_table"})

    if table:
        data = []
        rows = table.find("tbody").find_all("tr")  # Find all rows within tbody
        for row in rows:
            cols = row.find_all("td")
            cols = [col.text.strip() for col in cols]
            data.append(cols)

        df = pd.DataFrame(data)

        # Define column names
        df.columns = ["#", "Team", "Player", "H", "W", "P", "School", "C"]

        return df
    else:
        print("Table not found on the page.")
        return None

# Example usage:
url = "https://www.nbadraft.net/nba-mock-drafts/?year-mock=2025"
draft_df = scrape_nba_mock_draft(url)
if draft_df is not None:
    # Convert 'St.' to 'State' in the 'School' column
    # Use draft_df instead of df to access and modify the 'School' column
    draft_df['School'] = draft_df['School'].str.replace('St.', 'State', regex=False)
    draft_df.iloc[:, 0] = draft_df.iloc[:, 0].astype(int)
draft_df

# Convert the first column to integers, handling potential errors
try:
    draft_df.iloc[:, 0] = draft_df.iloc[:, 0].astype(int)
    print("First column successfully converted to integers.")
except ValueError as e:
    print(f"Error converting the first column to integers: {e}")
    print("Check the contents of the first column. It might contain non-numeric values.")
except Exception as e:
    print(f"An unexpected error occurred: {e}")
draft_df

# prompt: Filter the combined schedule df for only teams listed in the draft df. Look in both home teams and away teams.

# Filter the combined schedule df for only teams listed in the draft df
filtered_df = combined_df[combined_df['HomeTeam'].isin(draft_df['School']) | combined_df['AwayTeam'].isin(draft_df['School'])]
filtered_df

# prompt: filter so that each team only has their next upcoming game

# ... (Your existing code) ...

# Assuming 'combined_df' is your DataFrame with all games
# and 'draft_df' is your DataFrame with the NBA draft prospects and their schools

# Get a list of all teams from the draft
draft_teams = draft_df['School'].unique().tolist()


# Create an empty list to store the filtered data
upcoming_games = []

# Iterate through each team in the draft
for team in draft_teams:
    # Find the games for this team
    team_games = combined_df[(combined_df['HomeTeam'] == team) | (combined_df['AwayTeam'] == team)]

    if not team_games.empty:
        # Sort the games by date (ascending) to find the next game
        team_games_sorted = team_games.sort_values(by="DATE")

        # Get the next upcoming game
        next_game = team_games_sorted.iloc[0]
        upcoming_games.append(next_game)


# Create a new DataFrame from the filtered games
upcoming_games_df = pd.DataFrame(upcoming_games)
upcoming_games_df

home_merge = pd.merge(draft_df, upcoming_games_df, left_on='School', right_on='HomeTeam', how='inner')
away_merge = pd.merge(draft_df, upcoming_games_df, left_on='School', right_on='AwayTeam', how='inner')
final_df = pd.concat([home_merge, away_merge])
final_df_ordered = final_df.sort_values(by="#", ascending=True)

final_df_ordered[['#','Player', 'School', 'HOME', 'AWAY', 'DATE', 'TIME', 'LOCATION', 'ODDS', 'TV']]

# prompt: add a column to identify games where both the hometeam and the away team are in the school list from draft_df

# Create a new column 'BothTeamsInDraft'
final_df_ordered['SuperMatchup'] = final_df_ordered.apply(lambda row: (row['HomeTeam'] in draft_df['School'].values) and (row['AwayTeam'] in draft_df['School'].values), axis=1)
final_df_ordered

# prompt: create a separate dataframe for each respective date

# Assuming 'combined_df' is your DataFrame with all games

# Create a dictionary to store separate DataFrames for each date
date_dfs = {}

# Iterate through unique dates in the combined DataFrame
for date in final_df_ordered['DATE'].unique():
    # Filter the DataFrame for the current date
    date_df = final_df_ordered[final_df_ordered['DATE'] == date]

    # Store the DataFrame in the dictionary with the date as the key
    date_dfs[date] = date_df

# Access individual DataFrames using the date as the key
# Example: Accessing the DataFrame for the first date in the dictionary
#first_date = list(date_dfs.keys())[0]
#df_first_date = date_dfs[first_date]

# Print the DataFrame for the first date (optional)
#print(f"DataFrame for {first_date}:\n{df_first_date}")


# Now you can access each DataFrame using date_dfs[date]
# where 'date' is a datetime.date object.
date_dfs[date.today()]

# prompt: create an app to display the draft_df

import ipywidgets as widgets
from IPython.display import display, HTML

# Assuming final_df_ordered is your DataFrame
# and date_dfs is your dictionary of DataFrames by date

def display_dataframe(date_key):
    if date_key in date_dfs:
        df = date_dfs[date_key]
        display(HTML(df.to_html()))  # Display DataFrame as HTML
    else:
        print(f"No data found for {date_key}")


# Create a dropdown widget to select the date
date_options = list(date_dfs.keys())
date_dropdown = widgets.Dropdown(
    options=date_options,
    value=date_options[0],  # Set the default value
    description='Select Date:'
)

# Create an output widget to display the DataFrame
output = widgets.Output()

# Define the function to update the output based on the dropdown value
def on_date_change(change):
    with output:
        output.clear_output()  # Clear previous output
        display_dataframe(change['new'])


# Observe changes to the dropdown widget
date_dropdown.observe(on_date_change, names='value')

# Display the dropdown and output widgets
display(date_dropdown)
display(output)

# Initial display of the DataFrame for the selected date
with output:
    display_dataframe(date_dropdown.value)



